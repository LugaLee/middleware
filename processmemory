                                  Process and Memory 进程&&内存
                                  
# 	进程如何使用内存？

  	所有进程（执行的程序）都必须占用一定数量的内存，它或是用来存放从磁盘载入的程序代码，或是存放取自用户输入的数据等等。不过进程对这些内存的管理方式因内存
用途不一而不尽相同，有些内存是事先静态分配和统一回收的，而有些却是按需要动态分配和回收的。
  对任何一个普通进程来讲，它都会涉及到5种不同的数据段：
 （1）代码段：代码段是用来存放可执行文件的操作指令，也就是说是它是可执行程序在内存中的镜像。代码段需要防止在运行时被非法修改，所以只准许读取操作，而不允
             许写入（修改）操作——它是不可写的
 （2）数据段：数据段用来存放可执行文件中已初始化全局变量，换句话说就是存放程序静态分配的变量和全局变量
 （3）BSS段：BSS段包含了程序中未初始化的全局变量，在内存中bss段全部置零
 （4）堆（heap）：堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添
                 加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）从这个意义上讲，我们可以把堆栈看成一个寄存、交换
                 临时数据的内存区
 （5）栈：栈是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变量）。除此以外
         ，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中.从某种意义上讲，堆栈可以看成一个寄存、交
         换临时数据的内存区
				 
#		进程如何组织这些区域？
		内存区域中数据段、BSS和堆通常是被连续存储的——内存位置上是连续的，而代码段和栈往往会被独立存放。有趣的是，堆和栈两个区域关系很“暧昧”，他们一个向下“长”
（i386体系结构中栈向下、堆向上），一个向上“长”，相对而生。
 		从用户向内核看，所使用的内存表象形式会依次经历“逻辑地址”——“线性地址”——“物理地址”几种形式。逻辑地址经段机制转化成线性地址；线性地址又经过页机制转化为
物理地址。

#		进程内存如何分配与回收？
		创建进程fork()、程序载入execve()、映射文件mmap()、动态内存分配malloc()/brk()等进程相关操作都需要分配内存给进程。不过这时进程申请和获得的还不是实际
内存，而是“虚拟内存”，准确的说是“内存区域”。
		程对内存区域的分配最终都会归结到do_mmap（）函数上来（brk调用被单独以系统调用实现，不用do_mmap()），内核使用do_mmap()函数创建一个新的线性地址区间。
同样，释放一个内存区域应使用函数do_ummap()，它会销毁对应的内存区域。
		
		1、内存由虚拟——>物理形式
		从上面已经看到进程所能直接操作的地址都为“虚拟地址”。当进程需要内存时，从内核获得的仅仅是虚拟的内存区域，而不是实际的物理地址，进程并没有获得物理内存。
获得的仅仅是对一个新的线性地址区间的使用权。
		实际的物理内存只有“当进程真的去访问新获取的虚拟地址时”，才会由“请求页机制”产生“缺页”异常，从而进入分配实际页面的例程。该异常是虚拟内存机制赖以存在的
基本保证——它会告诉内核去真正为进程分配物理页，并建立对应的页表，这之后虚拟地址才实实在在地映射到了系统的物理内存上。

    2、物理内存管理
		虽然应用程序操作的对象是映射到物理内存之上的虚拟内存，但是处理器直接操作的却是物理内存。所以当应用程序访问一个虚拟地址时，首先必须将虚拟地址转化成物
理地址，然后处理器才能解析地址访问请求。地址的转换工作需要通过查询页表才能完成，概括地讲，地址转换需要将虚拟地址分段，使每段虚地址都作为一个索引指向页表，
而页表项则指向下一级别的页表或者指向最终的物理页面。
